var Socket=function(){"use strict";let e=Symbol("e");class Emitter{constructor(){this[e]=new Map}on(r,t){let n=this[e];return n.has(r)||n.set(r,new Set),n.get(r).add(t),this}event(r,...t){let n=this,o=n[e];if(o.has(r))for(let e of o.get(r))e.apply(n,t);return n}emit(e,...r){return this.event(e,...r)}once(e,r){let t=this,n=(...o)=>{r.apply(t,o),t.off(e,n)};return t.on(e,n),t}off(r,t){let n=this,o=n[e],a=o.get(r);return r?t?(a&&(a.delete(t),a.size||o.delete(a)),n):n[e].delete(r):n[e].clear()}}let r=(e,r)=>r instanceof e,t=(e,r)=>typeof e===r,n=Array.isArray,o=(e,r)=>r.hasOwnProperty(e),a=e=>{let t=ArrayBuffer,n=t.isView;return n&&n(e)||r(t,e)||r(t,e.buffer)||r(Blob,e)||r(File,e)},s=e=>{if(!t(e,"object"))return!1;if(a(e))return!0;if(n(e)){for(let r of e)if(s(r))return!0;return!1}let r=e.toJSON;if(r&&s(r()))return!0;for(let r in e)if(o(r,e)&&s(e[r]))return!0;return!1},c={0:"CONNECT",1:"EVENT",2:"BINARY_EVENT",CONNECT:0,EVENT:1,BINARY_EVENT:2},l=(e,s)=>{if(!e)return e;if(a(e)){let r={_placeholder:!0,num:s.length};return s.push(e),r}if(n(e)){let r=new Array(e.length);for(let t=0;t<e.length;t++)r[t]=l(e[t],s);return r}if(t(e,"object")&&!r(Date,e)){let r={};for(let t in e)o(t,e)&&(r[t]=l(e[t],s));return r}return e},i=e=>{if(s(e))throw new TypeError("Packet contains binary data");let r=""+e.type;return null!==e.data&&(r+=JSON.stringify(e.data)),r},d=e=>{if(!s(e))throw new TypeError("Packet doesn't contain binary data");let r=(e=>{let r=[],t=e.data,n=e;return n.data=l(t,r),n.binaries=r.length,{packet:n,buffers:r}})(e),t=r.packet,n=""+t.type+t.binaries,o=r.buffers;return null!=t.data&&(n+=JSON.stringify(t.data)),o.unshift(n),o};let p=(e,r)=>{if(e&&e._placeholder){if(t(e.num,"number")&&e.num>=0&&e.num<r.length)return r[e.num];throw new Error("Illegal attachments")}if(n(e))for(let t=0;t<e.length;t++)e[t]=p(e[t],r);else if(t(e,"object"))for(let t in e)o(t,e)&&(e[t]=p(e[t],r));return e};class Packer{constructor(e){let r=this;r.packet=e,r.buffers=[],r.packing=e}pop(e){let r=this;if(r.buffers.push(e),r.buffers.length===r.packing.binaries){let e=((e,r)=>(e.data=p(e.data,r),delete e.binaries,e))(r.packing,r.buffers);return r.done(),e}return null}done(){this.packing=null,this.buffers=[]}}let u=e=>{let r=e.match(/^[0-9]+/g)[0],o={type:+r[0]};if(void 0===c[o.type])throw new TypeError("Unknown packet type "+o.type);if(o.type===c.BINARY_EVENT){let e=+r.slice(1);if(!e)throw new Error("Illegal attachments");o.binaries=e}let a=e.substr(r.length);if(a.length){let e=(e=>{try{return JSON.parse(e)}catch(e){return!1}})(a);if(!((e,r)=>{switch(e){case c.CONNECT:return n(r);case c.EVENT:case c.BINARY_EVENT:return n(r)&&t(r[0],"string")}})(o.type,e))throw new Error("Payload data doesn't match packet type");o.data=e}return o};class Decoder extends Emitter{constructor(){super(),this.packer=null}add(e){let r,n=this;if(t(e,"string")){if(n.packer)throw n._clear(),new Error("Got plain text when building a packet");r=u(e),r.type===c.BINARY_EVENT?(n.packer=new Packer(r),0===r.binaries&&(n.emit("decoded",r),n._clear())):(n.emit("decoded",r),n._clear())}else{if(!a(e))throw new Error("Unknown data type: "+e);if(!n.packer)throw new Error("Got binary data when not building a packet");r=n.packer.pop(e),r&&(n.emit("decoded",r),n._clear())}}_clear(){let e=this;e.packer&&e.packer.done(),e.packer=null}}let f=new class Encoder{encode(e){return e.type===c.BINARY_EVENT?d(e):[i(e)]}};class Transport extends Emitter{constructor(e,r){super();let t=this,n=/^wss?:\/\//.test(e)?e:"ws://"+location.host+e,o=new WebSocket(n),a=new Decoder;t.open=!1,o.binaryType="arraybuffer",o.onopen=()=>{t.open=!0,t.emit("open")},o.onerror=e=>{let r=new Error("Connection error");r.code="connection_error",t.emit("error",r)},o.onclose=e=>{let r=new Error,t=this;switch(e.code){case 1e3:case 1001:t._close();break;case 1002:r.code="protoclol_error",r.message="Protocol error",t.emit("error",r);break;case 1006:r.code="server_error",r.message="Unexpected server close",t.emit("error",r);break;case 1011:r.code="request_error",r.message="Server could not process the request",t.emit("error",r);break;default:r.code="transport_error",r.message="Transport close",t.emit("error",r)}},o.onmessage=({data:e})=>{t.decoder.add(e)},a.on("decoded",(e=>{t.emit("packet",e)})),a.on("error",(e=>{e.code="decoder_error",t.emit("error",e)})),t.ws=o,t.decoder=a}_close(){let e=this,r=e.ws;e.open=!1,e.decoder.off(),e.decoder=null,r.onopen=r.onerror=r.onclose=r.onmessage=null,e.ws=null,e.emit("close"),e.off()}send(e){let r=this,t=f.encode(e);if(r.open)for(let e of t){if("[object Object]"===Object.prototype.toString.call(e))try{data=JSON.stringify(e)}catch(e){}this.ws.send(e)}else{let e=new Error("Transport not writable");e.code="write_error",r.emit("error",e)}}close(e){this.open&&this.ws.close(e)}}return class Socket extends Emitter{constructor(e,r={}){super();let t=this;t.id="",t.state="connecting",t.transport=null,t._createTransport(e,r),t.data={}}_createTransport(e,r){let t=new Transport(e,r),n=null,o=this;t.on("open",(()=>{clearInterval(n),o.transport=t})),t.on("packet",(e=>{let r=e.data;switch(e.type){case c.CONNECT:o._onConnect(r);break;case c.EVENT:case c.BINARY_EVENT:if("error connect disconnect".includes(r[0]))return o.event("error",new Error("Cannot emit reserved event: "+r[0]));o.event(...r);break;default:o.event("error",new Error("Unknown packet type: "+e.type))}})),t.on("error",(t=>{let a=2500+Math.floor(2501*Math.random());switch(t.code){case"transport_error":case"server_error":case"protocol_error":case"request_error":o.event("error",t),n=setInterval((()=>{clearInterval(n),o._createTransport(e,r)}),a);break;default:o.event("error",t)}})),t.on("close",(()=>{o.state="disconnected",o.transport=null,o.data=null,o.event("disconnect"),o.off()}))}_onConnect(e){let r=this,t=r.id;t.length||(r.id=e[0]),r.transport.send({type:c.CONNECT,data:[t]}),r.data=e[1],r.state="connected",r.event("connect")}emit(...e){if(!t(e[0],"string"))return this.event("error",new Error("Event must be a string"));this.transport.send({type:s(e)?c.BINARY_EVENT:c.EVENT,data:e})}close(e=1e3){this.transport.close(e)}get connected(){return this.transport.open}}}();